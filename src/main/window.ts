import * as path from 'path';

import { BrowserWindow, shell, dialog } from 'electron';

import log from './log';
import { resolveHtmlPath } from './util';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
// declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const isDevelopment = process.env.NODE_ENV === 'development';

let mainWindow: BrowserWindow | null;

export const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		show: false,
		width: 1024,
		height: 728,
		icon: path.join(__dirname, '../../icons/icon.ico'),
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			sandbox: false, // required for preload script to work
			nodeIntegration: false, // prevent node integration for security reasons
			contextIsolation: true, // protect against prototype pollution
		},
		/**
		 * Fix for pixelation on some Windows machines
		 * https://www.electronjs.org/docs/latest/faq#the-font-looks-blurry-what-is-this-and-what-can-i-do
		 */
		backgroundColor: '#fff',
	});

	if (isDevelopment) {
		mainWindow.webContents.openDevTools();
	}

	mainWindow.loadURL(resolveHtmlPath('index.html'));

	mainWindow.on('ready-to-show', () => {
		if (!mainWindow) {
			throw new Error('"mainWindow" is not defined');
		}
		if (process.env.START_MINIMIZED) {
			mainWindow.minimize();
		} else {
			mainWindow.show();
		}
	});

	mainWindow.on('closed', () => {
		mainWindow = null;
	});

	// Open urls in the user's browser
	mainWindow.webContents.setWindowOpenHandler((edata) => {
		shell.openExternal(edata.url);
		return { action: 'deny' };
	});

	// If page not found, go to index page
	// TODO - hack fix for reload when on a react-navigation route
	mainWindow.webContents.on('did-fail-load', async (event, errorCode, errorDescription) => {
		log.error(`did fail load with code ${errorCode}: ${errorDescription}`);
		if (errorDescription !== 'ERR_CONNECTION_REFUSED') {
			mainWindow.loadURL(resolveHtmlPath('index.html'));
		}
	});

	// Prevent all navigation events that would lead away from index.html
	// mainWindow.webContents.on('will-navigate', (event, url) => {
	// 	// Parse the path from the URL
	// 	const path = new URL(url).pathname;

	// 	event.preventDefault(); // Prevent the actual navigation

	// 	// Now you can handle the path within your SPA
	// 	// For example, send it to your renderer process:
	// 	mainWindow?.webContents.send('navigate', path);
	// });

	// Handle HID device selection
	mainWindow.webContents.session.on('select-hid-device', (event, details, callback) => {
		console.log('devicelist', details.deviceList);

		mainWindow?.webContents.session.on('hid-device-added', (event, device) => {
			console.log('hid-device-added FIRED WITH', device);
			// find device with 'Scanner' in product name
			const scanner = details.deviceList.find((device) => device.name.includes('Scanner'));
			if (scanner) {
				callback(scanner.deviceId);
			} else {
				dialog.showErrorBox('Error', 'No scanner found');
			}
		});

		mainWindow?.webContents.session.on('hid-device-removed', (event, device) => {
			console.log('hid-device-removed FIRED WITH', device);
			// Optionally update details.deviceList
		});

		event.preventDefault();

		if (details.deviceList && details.deviceList.length > 0) {
			// find device with 'Scanner' in product name
			const scanner = details.deviceList.find((device) => device.name.includes('Scanner'));
			if (scanner) {
				callback(scanner.deviceId);
			} else {
				dialog.showErrorBox('Error', 'No scanner found');
			}
		} else {
			console.log('No HID devices found.');
		}
	});

	// Permission check handler for HID
	mainWindow.webContents.session.setPermissionCheckHandler(
		(webContents, permission, requestingOrigin, details) => {
			console.log('permission check', permission, requestingOrigin, details);
			if (permission === 'hid') {
				return true;
			}
			return false;
		}
	);

	// Device permission handler for HID
	mainWindow.webContents.session.setDevicePermissionHandler((details) => {
		console.log('device permission', details);
		if (details.deviceType === 'hid') {
			return true;
		}
		return false;
	});
};

export const getMainWindow = (): BrowserWindow | null => {
	return mainWindow;
};
